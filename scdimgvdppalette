#!/usr/bin/env perl
###############################################################################
# Copyright (c) 2011 by bgvanbur
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
###############################################################################
# convert images to asm files for megadrive/megacd development
###############################################################################

# TODO ability to change imgLabel?
# TODO more verbosity...
# TODO reduce size to 320x240 if larger (scaling)

use strict;
use warnings;
use Image::Magick;

use FindBin;
use lib $FindBin::Bin;
use SCDTools::Palette;

my $palette = SCDTools::Palette->new();

if ( $#ARGV < 0 ) {
    &Help();
}

my $verbosity = 2;

my $colorCountMax = 15;

my @imgFiles;

my $resizeWidth = 0;
my $resizeHeight = 0;
my $resizeToTiles = 0;
my $ditherVdp = 'fs';
my $ditherQuantize = 'fs';
my $ditherFinal = 'fs';
my $debug = 0;

foreach my $arg (@ARGV) {
    if ( $palette->ParseArg($arg) ) {
	# do nothing
    } elsif ( $arg =~ /^-resize=(\d+)x(\d+)$/i ) {
	$resizeWidth = $1;
	$resizeHeight = $2;
    } elsif ( $arg =~ /^-resizetotiles?$/i ) {
	$resizeToTiles = 1;
    } elsif ( $arg =~ /^-dither=(none|r|fs)$/i ) {
	$ditherVdp = lc($1);
	$ditherQuantize = lc($1);
	$ditherFinal = lc($1);
    } elsif ( $arg =~ /^-dithervdp=(none|r|fs)$/i ) {
	$ditherVdp = lc($1);
    } elsif ( $arg =~ /^-ditherquantize=(none|r|fs)$/i ) {
	$ditherQuantize = lc($1);
    } elsif ( $arg =~ /^-ditherfinal=(none|r|fs)$/i ) {
	$ditherFinal = lc($1);
    } elsif ( $arg =~ /^-debug$/i ) {
	$debug = 1;
    } elsif ( -e $arg ) {
	push @imgFiles, $arg;
    } else {
	print STDERR "\nCould not parse argument: $arg\n";
	&Help();
    }
}

$palette->ReadPalette();
my $useColors = ( $palette->GetColorsCount() > 0 ? 1 : 0 );

if ( ! $useColors ) {
    # if not using palette allow lots of palettes for color overflow
    $palette->SetPaletteCount(512/16);
}

foreach my $imgFile (@imgFiles) {
    &ImgExtractColors($imgFile);
}



###############################################################################


sub ImgExtractColors($) {
    my ($imgFile) = @_;

    my $imgLabel = $imgFile;
    $imgLabel =~ s/\..*$//g;
    $imgLabel =~ s/[^A-Za-z0-9]//g;

    my $imgOriginal = Image::Magick->new();
    my $x = $imgOriginal->ReadImage($imgFile);
    warn $x if $x;

    if ( $resizeWidth && $resizeHeight ) {
	# possible filters: Point, Box, Triangle, Hermite, Hanning, Hamming, Blackman, Gaussian, Quadratic, Cubic, Catrom, Mitchell, Lanczos, Bessel, Sinc
	$imgOriginal->Resize('width'=>$resizeWidth,'height'=>$resizeHeight,'filter'=>'Cubic');
    } elsif ( $resizeToTiles ) {
	my $width = $imgOriginal->Get('width');
	my $height = $imgOriginal->Get('height');
	if ( $width % 8 != 0 || $height % 8 != 0 ) {
	    my $widthNew = ($width+7) & 0xFFF8;
	    my $heightNew = ($height+7) & 0xFFF8;
	    $imgOriginal->Extent('width'=>$widthNew,'height'=>$heightNew,'x'=>(($widthNew-$width)>>1),'y'=>(($heightNew-$heightNew)>>1),'background'=>'rgb(0,0,0)');
	}
    }

    my $img = $imgOriginal->Clone();

    if ( ! $useColors ) {
	# reset back to zero colors
	$palette->SetMaxColorCount(0);

	$palette->AddColorsFromImageMagickImage($img);
    }

    my $colorsLength = $palette->GetColorsCount();

    my $imgPalette = Image::Magick->new();
    $palette->UpdateImageMagickPalette($imgPalette);
    
    if ( $debug ) {
	my $file = 'scdimgvdppalette_debugpal0_'.$imgFile;
	print "Writing $file (VDP color palette for original image)\n";
	$imgPalette->Write($file);
    }

    if ( $colorsLength > $colorCountMax ) {
	if ( $ditherVdp eq 'none' ) {
	    $img->Remap('image'=>$imgPalette,dither=>'false');
	} elsif ( $ditherVdp eq 'r' ) {
	    $img->Remap('image'=>$imgPalette,dither=>'true','dither-method'=>'Riemersma');
	} elsif ( $ditherVdp eq 'fs' ) {
	    $img->Remap('image'=>$imgPalette,dither=>'true','dither-method'=>'Floyd-Steinberg');
	} else {
	    die "Bad dither final: $ditherVdp\n";
	}

	if ( $debug ) {
	    my $file = 'scdimgvdppalette_debugimg0_'.$imgFile;
	    print "Writing $file (mapped to VDP colors, too many colors for single palette still)\n";
	    $img->Write($file);
	}

	undef $imgPalette;

	$img = $imgOriginal->Clone();

	if ( $ditherQuantize eq 'none' ) {
	    $img->Quantize('colors'=>$colorCountMax,'measure_error'=>'true','treedepth'=>8,'dither'=>'false');
	} elsif ( $ditherQuantize eq 'r' ) {
	    $img->Quantize('colors'=>$colorCountMax,'measure_error'=>'true','treedepth'=>8,'dither'=>'true','dither-method'=>'Riemersma');
	} elsif ( $ditherQuantize eq 'fs' ) {
	    $img->Quantize('colors'=>$colorCountMax,'measure_error'=>'true','treedepth'=>8,'dither'=>'true','dither-method'=>'Floyd-Steinberg');
	} else {
	    die "Bad dither final: $ditherQuantize\n";
	}

	if ( $debug ) {
	    my $file = 'scdimgvdppalette_debugimg1_'.$imgFile;
	    print "Writing $file (quantized to $colorCountMax VDP colors)\n";
	    $img->Write($file);
	}

	if ( ! $useColors ) {
	    # reset back to zero colors
	    $palette->SetMaxColorCount(0);

	    $palette->AddColorsFromImageMagickImage($img);
	    $colorsLength = $palette->GetColorsCount();
	}

	# TODO needed?
	# if ( $colorsLength < $colorCountMax ) {
	#     if ( $magicPink ) {
	# 	$palette->GetColorIndex(chr(0x0E).chr(0x0E));
	#     } elsif ( $magicBlack ) {
	# 	$palette->GetColorIndex(chr(0x00).chr(0x00));
	#     }
	# }

	# $colorsLength = $palette->GetColorsCount();

	if ( $colorsLength > $colorCountMax ) {
	    print STDERR "Quantization went beyond color count\n";
	    $palette->SetMaxColorCount($colorCountMax);
	}

	$colorsLength = $palette->GetColorsCount();

	print "Quantization resulted in $colorsLength VDP colors\n";

	$imgPalette = Image::Magick->new();
	$palette->UpdateImageMagickPalette($imgPalette);

	if ( $debug ) {
	    my $file = 'scdimgvdppalette_debugpal1_'.$imgFile;
	    print "Writing $file (VDP color palette after quantization)\n";
	    $imgPalette->Write($file);
	}

	$img = $imgOriginal->Clone();
    } elsif ( ! $useColors ) {
	print "Image only has $colorsLength VDP colors\n";
    }

    if ( $ditherFinal eq 'none' ) {
	$img->Remap('image'=>$imgPalette,dither=>'false');
    } elsif ( $ditherFinal eq 'r' ) {
	$img->Remap('image'=>$imgPalette,dither=>'true','dither-method'=>'Riemersma');
    } elsif ( $ditherFinal eq 'fs' ) {
	$img->Remap('image'=>$imgPalette,dither=>'true','dither-method'=>'Floyd-Steinberg');
    } elsif ( ! $useColors ) {
	die "Bad dither final: $ditherFinal\n";
    }

    {
	my $file = 'scdimgvdppalette_'.$imgFile;
	if ( $debug ) {
	    print "Writing $file (original image dithered to quatized colors)\n";
	}
	$img->Write($file);
    }
}

sub Help {
    die '
scdimgvdppalette [options] <imgfiles>

[description]
  Convert image to Sega VDP palette with dithering/quantization.
  It is suggested to avoid transparency since they can become partially
  transparent in the process and typically result in ugly edges.
  Still a work in progress.

'.$palette->GetHelpString().'[options]
  -resize=<x>x<y>            resize to a specific size
  -resizetotiles             resize the image to a tile boundary
                             (centered and uses black for pixel fill)

[dither options]
  -dither=<dither>           set all dithering
  -dithervdp=<dither>        set dithering of palette to VDP colors
  -ditherquantize=<dither>   set dithering of palette quantization
  -ditherfinal=<dither>      set dithering of final image
  <dither>                   none - no dithering
                             r    - Riemersma dithering
                             fs   - Floyd-Steinberg dithering (default)

';
}
