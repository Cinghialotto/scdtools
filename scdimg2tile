#!/usr/bin/env perl
###############################################################################
# Copyright (c) 2011 by bgvanbur
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
###############################################################################
# convert images to asm files for megadrive/megacd development
###############################################################################

# TODO ability to change imgLabel?
# TODO more verbosity...

use strict;
use warnings;
use Image::Magick;

# Graphics::Magick doesn't appear to have easy way to get pixel alpha value

if ( $#ARGV < 0 ) {
    &Help();
}

my $verbosity = 2;

my $paletteGet = 0;
my $paletteFile = '';
my $paletteOffset = 0;
my $paletteCount = 1;

my $map = 0;
my $mapOffset = 0;
my $showMap = 0;
my $showTiles = 0;
my $sequentialMap = 0;
my $compress = 0;
my $magicPink = 0;
my $magicBlack = 0;
my $labels = 1;
my $bin = 0;
my $grey = 0;

# TODO make option
my $dither4x2 = 0;
my $dither2x2 = 0;
my $ditherFS = 0;
my $ditherR = 0;

my @imgFiles;

my %missingColors;

foreach my $arg (@ARGV) {
    if ( $arg =~ /^-palfile=(.+)$/i ) {
	$paletteFile = $1;
    } elsif ( $arg =~ /^-palget$/i ) {
	$paletteGet = 1;
    } elsif ( $arg =~ /^-palcount=(\d+)$/i ) {
	$paletteCount = $1;
    } elsif ( $arg =~ /^-palbyteoffset=(\d+)/i ) {
	$paletteOffset = $1;
    } elsif ( $arg =~ /^-paloffset=(\d+)$/i ) {
	$paletteOffset = 32 * $1;
    } elsif ( $arg =~ /^-map$/i ) {
	$map = 1;
    } elsif ( $arg =~ /^mapoffset=(\d+)$/i ) {
	$map = 1;
	$mapOffset = $1;
    } elsif ( $arg =~ /^-showmap$/i ) {
	$map = 1;
	$showMap = 1;
    } elsif ( $arg =~ /^-showtiles$/i ) {
	$map = 1;
	$showTiles = 1;
    } elsif ( $arg =~ /^-sequentialmap$/i ) {
	$map = 1;
	$sequentialMap = 1;
    } elsif ( $arg =~ /^-compress=(\d+)$/i ) {
	$compress = $1;
    } elsif ( $arg =~ /^-magicpink$/i ) {
	$magicPink = 1;
    } elsif ( $arg =~ /^-magicblack$/i ) {
	$magicBlack = 1;
    } elsif ( $arg =~ /^-nolabels$/i ) {
	$labels = 0;
    } elsif ( $arg =~ /^-bin$/i ) {
	$bin = 1;
	$labels = 0;
    } elsif ( $arg =~ /^-gr[ae]y$/i ) {
	$grey = 1;
    } elsif ( $arg =~ /^-dither=4x2$/i ) {
	$dither4x2 = 1;
    } elsif ( $arg =~ /^-dither=2x2$/i ) {
	$dither2x2 = 1;
    } elsif ( $arg =~ /^-dither=fs$/i ) {
	$ditherFS = 1;
    } elsif ( $arg =~ /^-dither=r$/i ) {
	$ditherR = 1;
    } elsif ( $arg =~ /^-v=(\d+)$/i ) {
	$verbosity = $1;
    } elsif ( -e $arg ) {
	push @imgFiles, $arg;
    } else {
	print STDERR "\nCould not parse argument: $arg\n";
	&Help();
    }
}

# [ 0 3 ]
# [ 2 1 ]

my @orderDitherMatrix2x2 = ( 0, 3, 2, 1 );

# [ 0 6 1 7 ]
# [ 4 2 5 3 ]

my @orderDitherMatrix4x2 = ( 0, 6, 1, 7, 4, 2, 5, 3 );

if ( ! ( -e $paletteFile || $paletteGet ) || $#imgFiles < 0 ) {
    print STDERR "\nNeed to specify -palfile and at least one img file\n";
    &Help();
}

if ( ! $showMap && ! $showTiles && ! $paletteGet ) {
    $showTiles = 1;
}

my $paletteData;

if ( ! $paletteGet ) {
    $paletteData = &ReadPalette();
}

my $img;
my @tiles;
my $alpha = 0;

foreach my $imgFile (@imgFiles) {
    &Img2Tile($imgFile);
}

my @colors = sort {$missingColors{$b} <=> $missingColors{$a}} keys %missingColors;

if ( $paletteGet ) {
    my $index = 0;
    if ( $#colors + 1 > $paletteCount * 16 - 1 ) {
	print STDERR "Too many colors for one palette (will use most frequent colors)\n";
    }
    for ( my $paletteIndex = 0; $paletteIndex < $paletteCount; $paletteIndex++ ) {
	if ( $bin ) {
	    print pack("n",0x0000);
	} else {   
	    print ";; palette\n";
	    print " dc.w 0x0000\n";
	}
	for ( my $i = 0; $i < 15; $i++ ) {
	    my $colorsIndex = $paletteIndex * 15 + $i;
	    if ( $colorsIndex <= $#colors ) {
		if ( $bin ) {
		    print $colors[$colorsIndex];
		} else {
		    my $colorf = sprintf("0x%4.4X",unpack("n",$colors[$colorsIndex]));
		    print ' dc.w '.$colorf."\n";
		}
	    } else {
		if ( $bin ) {
		    print pack("n",0x0000);
		} else {
		    print " dc.w 0x0000\n";
		}
	    }
	}
    }
} else {
    foreach my $color (@colors) {
	my $count = $missingColors{$color};
	my $colorf = sprintf("0x%4.4X",unpack("n",$color));
	print STDERR "Palette does not contain color: $colorf ($count)\n";
    }
}


###############################################################################


sub Img2Tile($) {
    my ($imgFile) = @_;

    @tiles = ();

    my $imgLabel = $imgFile;
    $imgLabel =~ s/\..*$//g;
    $imgLabel =~ s/[^A-Za-z0-9]//g;

    $img = Image::Magick->new();
    my $x = $img->ReadImage($imgFile);
    warn $x if $x;
    $alpha = $img->Get('matte');
    my $width = $img->Get('width');
    my $height = $img->Get('height');

    # TODO an attempt to look at dithering
    if ( $ditherFS || $ditherR ) {
	my $colorsLength = length($paletteData)>>1;

	my $imgPalette = Image::Magick->new();
	$imgPalette->Set(size=>"${colorsLength}x1");
	$x = $imgPalette->ReadImage('xc:black');
	warn $x if $x;

	for ( my $x = 0; $x < $colorsLength; $x++ ) {
	    my $c = substr($paletteData,$x*2,2);
	    my @pixels = ( (   ord(substr($c,0,1))        & 0xE ) / 14,
			   ( ( ord(substr($c,1,1)) >> 4 ) & 0xE ) / 14,
			   (   ord(substr($c,1,1))        & 0xE ) / 14 );
	    for ( my $i = 0; $i < 3; $i++ ) {
		$pixels[$i] = $pixels[$i]*0.95 + 0.025;
	    }
	    $imgPalette->SetPixel('channel'=>'RGB','x'=>$x,'y'=>0,'color'=>\@pixels);
	}
    
	if ( $ditherFS ) {
	    $img->Remap('image'=>$imgPalette,'dither'=>'true','dither-method'=>'Floyd-Steinberg');
	} elsif ( $ditherR ) {
	    $img->Remap('image'=>$imgPalette,'dither'=>'true','dither-method'=>'Riemersma');
	}
    }

    my $w = $width / 8;
    my $h = $height / 8;
    if ( ! $bin && ! $paletteGet ) {
	if ( $map ) {
	    print " ;; map (${w}x${h})\n";
	} else {
	    print " ;; sprite ordering from (${w}x${h})\n";
	}
    }

    if ( $labels && ( $showMap || $showTiles ) ) {
	print "${imgLabel}TileWidth: equ ${w}\n";
	print "${imgLabel}TileHeight: equ ${h}\n";
    }

    if ( $map ) {
	if ( $labels && $showMap ) {
	    print "Start${imgLabel}Map:\n";
	}
	for ( my $y = 0; $y < $height; $y += 8 ) {
	    my $map;
	    for ( my $x = 0; $x < $width; $x += 8 ) {
		$map .= chr(&ReadImgTile($x,$y));
	    }
	    if ( $showMap ) {
		if ( ! $bin ) {
		    print " dc.b ";
		}
		for ( my $i = 0; $i < length($map); $i++ ) {
		    if ( $bin ) {
			print substr($map,$i,1);
		    } else {
			print ',' if $i;
			printf("\$%2.2X",ord(substr($map,$i,1)));
		    }
		}
		if ( ! $bin ) {
		    print "\n";
		}
		if ( $labels && $y == 0 ) {
		    print "StartRow${imgLabel}Map:\n";
		}
	    }
	}
	if ( $labels && $showMap ) {
	    print "End${imgLabel}Map:\n";
	}
    } else {
	# sprite read tiles sequentially in sprite order
	for ( my $x = 0; $x < $width; $x += 8 ) {
	    for ( my $y = 0; $y < $height; $y += 8 ) {
		&ReadImgTile($x,$y);
	    }
	}
    }

    if ( $showTiles ) {
	if ( $labels ) {
	    print "Start${imgLabel}Tiles:\n";
	}
	if ( ! $bin && $compress ) {
	    print " ;; compressed $compress\n";
	}
	for ( my $tileIndex = 0; $tileIndex <= $#tiles; $tileIndex++ ) {
	    if ( ! $bin ) {
		printf(" ;; tile \$%2.2X\n",$tileIndex+$mapOffset);
	    }
	    if ( $compress == 0 ) {
		for ( my $i = 0; $i < length($tiles[$tileIndex]); $i += 4 ) {
		    if ( $bin ) {
			print substr($tiles[$tileIndex],$i,4);
		    } else {
			printf(" dc.l \$%8.8X\n",unpack("N",substr($tiles[$tileIndex],$i,4)));
		    }
		}
	    } elsif ( $compress == 1 ) {
		for ( my $i = 0; $i < length($tiles[$tileIndex]); $i += 4 ) {
		    my $v0 = unpack("n",substr($tiles[$tileIndex],$i,2));
		    my $v1 = unpack("n",substr($tiles[$tileIndex],$i+2,2));
		    my $value = $v0 | ( $v1 << 2 );
		    if ( $bin ) {
			print pack("n",$value);
		    } else {
			printf(" dc.w \$%4.4X\n",$value);
		    }
		}
	    } elsif ( $compress == 2 ) {
		for ( my $i = 0; $i < length($tiles[$tileIndex]); $i += 8 ) {
		    my $v0 = unpack("n",substr($tiles[$tileIndex],$i,2));
		    my $v1 = unpack("n",substr($tiles[$tileIndex],$i+2,2));
		    my $v2 = unpack("n",substr($tiles[$tileIndex],$i+4,2));
		    my $v3 = unpack("n",substr($tiles[$tileIndex],$i+6,2));
		    my $value = $v0 | ( $v1 << 1 ) | ( $v2 << 2 ) | ( $v3 << 3 );
		    if ( $bin ) {
			print pack("n",$value);
		    } else {
			printf(" dc.w \$%4.4X\n",$value);
		    }
		}
	    } else {
		die "Unsupported compress argument\n";
	    }
	}
	if ( $labels ) {
	    print "End${imgLabel}Tiles:\n";
	}
    }
}

sub ReadPalette {
    if ( ! -e $paletteFile ) {
	die "Bad palette file: $paletteFile";
    }
    if ( $paletteFile =~ m/\.(asm|68k)$/i ) {
	my $paletteAsmFile = $paletteFile;
	$paletteFile = 'TMP.BIN';
	system("scdasm -v=$verbosity $paletteAsmFile $paletteFile");
	if ( ! -e $paletteFile ) {
	    die "Bad scdasm since didn't make: $paletteFile";
	}
    }

    my $paletteData = chr(0x00)x32;

    open( PALETTE, $paletteFile ) or die "Cannot read palette file: $!\n";
    binmode PALETTE;
    seek(PALETTE,$paletteOffset,0);
    my $paletteDataBuffer;
    if ( read(PALETTE,$paletteDataBuffer,32) == 32 ) {
	$paletteData = $paletteDataBuffer;
    }
    close PALETTE;

    return $paletteData;
}

# process an 8x8 tile
sub ReadImgTile {
    my ($x,$y) = @_;
    my $tile = '';
    my $a = 0;
    my $y2;
    my $x2;
    my $i;
    my $valueHi;
    my $valueLo;
    my $tileUsed = -1;
    for ( my $subrow = 0; $subrow < 8; $subrow++ ) {
	# process each of the resulting four bytes
	$y2 = $y+$subrow;
	for ( $i = 0; $i < 4; $i++ ) {
	    $x2 = $x+2*$i;
	    # process two pixels for a hi and lo nibble
	    #if ( $alpha ) {
	    #$a = $img->GetPixel('channel'=>'Alpha','normalize'=>1,'x'=>$x2,'y'=>$y2);
	    #}
	    #$valueHi = &GetPaletteIndex($img->GetPixel('channel'=>'RGB','normalize'=>1,'x'=>$x2,'y'=>$y2),$a);
	    $valueHi = &GetPaletteIndex($img,$x2,$y2,$alpha);
	    #if ( $alpha ) {
	    #$a = $img->GetPixel('channel'=>'Alpha','normalize'=>1,'x'=>($x2+1),'y'=>$y2);
	    #}
	    #$valueLo = &GetPaletteIndex($img->GetPixel('channel'=>'RGB','normalize'=>1,'x'=>($x2+1),'y'=>$y2),$a);
	    $valueLo = &GetPaletteIndex($img,$x2+1,$y2,$alpha);
	    $tile .= chr(( $valueHi << 4 ) | $valueLo);
	}
    }
    # for sprites, do not reuse existing tiles
    if ( $map && ! $sequentialMap ) {
	for ( my $tileIndex = 0; $tileIndex <= $#tiles; $tileIndex++ ) {
	    if ( $tiles[$tileIndex] eq $tile ) {
		$tileUsed = $tileIndex + $mapOffset;
		last;
	    }
	}
    }
    if ( $tileUsed < 0 ) {
	push @tiles, $tile;
	$tileUsed = $#tiles + $mapOffset;
    }
    return $tileUsed;
}

# performance
my %cacheGetPaletteIndex;

# convert a normalized RGBA value to a sega palette index
sub GetPaletteIndex {
    my ($img,$x,$y,$alpha) = @_;
    # if fully transparent, shortcut out with transparent index
    if ( $alpha ) {
	my $a = $img->GetPixel('channel'=>'Alpha','normalize'=>1,'x'=>$x,'y'=>$y);
	if ( defined $a && $a == 1 ) {
	    return 0;
	}
    }
    my ($r,$g,$b) = $img->GetPixel('channel'=>'RGB','normalize'=>1,'x'=>$x,'y'=>$y);
    #my ($r,$g,$b,$a) = @_;
    # 0x00-0x1F,0x20-0x3F...
    my $orderedDitherAdd = 0;
    if ( $dither4x2 ) {
	$orderedDitherAdd = $orderDitherMatrix4x2[(4*($y & 1)+($x & 3))] << 2;
    } elsif ( $dither2x2 ) {
	$orderedDitherAdd = $orderDitherMatrix2x2[(2*($y & 1)+($x & 1))] << 3;
    }
    my $color;
    if ( $grey ) {
	my $avg = int((85*($r+$g+$b)+$orderedDitherAdd)>>5);
	if ( $avg > 7 ) {
	    $avg = 7;
	}
	$color = chr($avg<<1).chr(($avg<<5)|($avg<<1));
    } else {
	# TODO add in orderedDitherAdd
	$color = chr(int((255*$b)>>5)<<1).chr((int((255*$g)>>5)<<5)|(int((255*$r)>>5)<<1));
    }
    my $index = -1;
    if ( exists $cacheGetPaletteIndex{$color} ) {
	$index = $cacheGetPaletteIndex{$color};
	if ( ! $paletteGet ) {
	    return $index;
	}
    } elsif ( ( $magicPink && $color eq (chr(0x0E).chr(0x0E)) ) ||
	      ( $magicBlack && $color eq (chr(0x00).chr(0x00)) ) ) {
	# check for transparent pixel if alpha channel in image
	# check for magic pink (#FF00FF)
	$index = 0;
    } elsif ( ! $paletteGet ) {
	# start with 1 to avoid picking transparent index
	# do check index 0 if no other matches found
	for ( my $i = 1; $i <= 16; $i++ ) {
	    if ( $color eq substr($paletteData,($i%16)*2,2) ) {
		$index = $i;
		last;
	    }
	}
    }

    if ( $index < 0 || $paletteGet ) {
	$missingColors{$color}++;
    }

    if ( $index < 0 ) {
	$index = 0;
    }

    $cacheGetPaletteIndex{$color} = $index;

    return $index;
}

sub Help {
    die '
scdimg2tile [options] <imgfiles...>

[description]
  converts images to the Sega VDP format (assembly files with optional labels)

[options]
  -palget             get the Sega VDP palette(s) from the images
  -palcount=<#>       specifies the number of palettes in use
  -palfile=<file>     specifies the palette data
  -paloffset=<#>      palette offset of the first palette in the palette file
  -palbyteoffset=<#>  byte offset of the first palette in the palette file
  -map                Sega VDP data should be in map order (default is sprite)
  -showmap            produces a map that has tile reuse
  -sequentialmap      do not reuse tiles
  -compress=<#>       compresses the tile data for reduced colors
                      1: compress to 2 bit color map (4 colors)
                      2: compress to 1 bit color map (2 colors)
  -magicpink          treat #FF00FF as transparent
  -magicblack         treat #000000 as transparent
  -nolabels           do not print any labels in out
  -bin                output binary instead of assembly
  -grey               averages colors for using greyscale palette
  -dither=4x2         ordered dither using 4x2 matrix (TODO only -grey for now)
  -dither=2x2         ordered dither using 2x2 matrix (TODO only -grey for now)
  -dither=fs          dither using Floyd-Steinberg
  -dither=r           dither using Riemersma
  -v=<#>              specify verbosity

';
}
